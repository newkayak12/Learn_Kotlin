# 기본 문법

## 주석
|표현|    설명    |
|:---:|:--------:|
|//  |    주석    |
|/* */ |  여러 줄 주석 |
|/** */ |   KDoc   |


## 변수 정의

### 식별자
변수, 함수 등 프로그램에 정의된 대상에 붙은 이름

1. 식별자는 오직 문자, 숫자, 밑줄만 포함, 숫자로 식별자 시작 불가
2. 밑줄로만 이뤄질 수 있다. '_', '__', '___' 는 예약어
3. 하드 키워드는 식별자로 불가 - (val, fun 등 -> 소트 키워드 : import 등)

> vs. Java
> - $를 식별자로 쓸 수 없다.
> - \`\`로 감싸는 경우도 식별자로 사용할 수 있다.
> 
> val `fun` = 1
> val `name with spaces` = 2


### 가변 변수
`val`은 불변 변수다. 한 번 초기화하면 다시는 값을 대입할 수 없는 변수다. (java final) 이를 하면 함수가 부수효과(SideEffect)가 줄어든다. 함수형 스타일
코드를 장려할 수 있다. 또한 코드 추론이 쉬워진다. 

`var`은 mutable한 변수를 정의할 수 있다. 

> vs. Java
> 코틀린 대입은 대입문이라 return 이 없다.
> a = b = c 와 같은 케이스를 사용할 수 없다.


## 기본 타입

자바의 원시 타입과 비슷하지만 다르다. 1:1 대응은 아니다. 자바는 값 타임, 참조 타입 간의 차이가 확실하다. 코틀린은 상황에 따라 참조와 원시 타입을 가리키기 
때문에 구분이 모호하다. 자바는 박싱 타입이 따로 있지만 코틀린은 암묵적으로 수행한다.


> vs. Java
> - 코틀린의 모든 타입은 클래스 정의를 기반으로 만들어진다. 원시 타입과 비슷한 타입들도 메소드와 프로퍼티를 제공한다. 
> - 타입은 하위 타입이라는 개념으로 게층화할 수 있다. 

### 정수 타입
 
- Byte
- Short
- Int
- Long

### 부동소수점

- Float
- Double

```kotlin
val quarter = .25 //0이 생략됨
```


### 수 변환
각 수 타입마다 값을 다른 수 타입으로 변환하는 연산이 정의돼 있다. 

- toByte()
- toShort()
- toInt()
- toLong()
- toFloat()
- toDouble()

### 비교 동등성

1. 둘 다 같은 타입일 때 비교 가능
```kotlin
val a = 1;
val b = 2L

println(a == b) // Error: comparing Int And Long
println(a.toLong() == b) //OK!
```

## Bool 타입, 논리 연산

- ! : 논리 부정
- or(| 대체), and(& 대체), xor : 논리합, 논리곱, 논리배타합
- ||, && : 지연 계산 방식의 논리합, 논리곱

## 문자열
1. 코틀린은 \"\" 사이에 `${}`으로 interpolation을 할 수 있다.
2. raw 문자열을 사용하면 이스케이프 없이 쓸 수도 있다.

```kotlin
val message = """
    Hello, $name!
""".trimIndent()
```

### 문자열 연산

> vs. Java
> 자바의 ==, !=는 참조 동등성을 비교한다. 그래서 equals()를 사용해야만 한다.
> 코틀린에서는 == 가 equals()를 가리키는 편의 문법이다.
> 
> 문자열은 사전식으로 정렬되기에(lexicographically) `<`, `>`, `<=`, `>=`으로 비교할 수 있다.

## 배열
1. 배열 구조를 구현하는 가장 일반적인 코틀린 타입은 `Array<T>`이다.
2. 추가로 Array<Int>는 작동은 하지만 모든 수를 박싱한다. `ByteArray`, `ShortArray`, `IntArray`, `LongArray`, `FloatArray`, `DoubleArray`, `CharArray`, `BooleanArray`처럼 박싱하지 않는 배열이 구현되어 있다.
3. 배열 타입의 변수 자체는 실제 데이터에 대한 참조를 저장한다.
4. 코틀린 배열은 모든 다른 배열 타입과 서로 하위 타입 관계가 성립하지 않는다고 간주되며 `Array<String>`은 `Array<Any>`의 하위가 아니다.


## 함수 
- `fun`는 컴파일러에게 함수 정의가 뒤따라온다는 사실을 알려준다.
- 아무 식별자나 함수명으로 쓸 수 있다.
- 자바는 final을 붙여야 불변 값으로 바꿀 수 있는데 코틀린은 함수 파라미터는 무조건 불변

```java
public int test (final int a ) {return a;}
```
```kotlin
fun test( a: Int ) : Int {return a}
```

- 코틀린 파라미터 앞에 val, var을 표시할 수 없다.
- 코틀린의 값에 의한 호출을 사용한다. (호출하는 쪽의 인자를 복사한다.)
- 파라미터에는 항상 타입을 지정해야 한다. 컴파일러는 함수 정의에서 파라미터 타입은 추론하지 못한다.
- 반환 타입은 추론가능하지만 명시해야 한다. 그러나 함수 본문에서 모든 반환 지점을 보고 추론하기 어려울 수 있기에 명시한다.
- 경우에 따라 생략할 수 있다. 첫 번째는 unit 타입 반환(자바의 void), 두 번째는 식이 본문 식인 함수다. 함수가 어떤 단일 식으로만 구현될 수 있다면 `return`, `{}`를 생략하고 작성할 수 있다.

```kotlin
import kotlin.math.PI
import kotlin.math.pow

fun circleArea1(radius: Double) = PI * radius.pow(2.0)
fun circleArea2(radius: Double) = {PI * radius.pow(2.0)} // 블록이 본문인 함수를 정의할 때 {} 앞에 =를 넣으면 익명 함수를 기술하는 람다로 해석된다.
```


## 위치기반 인자, 이름 붙은 인자
- 코틀린은 자바와 같이 parameter의 위치에 따른 식별을 기본적으로 적용한다.

```kotlin
fun test( a: Int, b: String) {
}


fun main() {
    test(1, "1")
}

```

- 코틀린은 swift같이 이름 붙은 인자(named argument)라는 방식도 제공한다.

```kotlin
fun test( a: Int, b: String) {
}


fun main() {
    test(b = "1", a = 1)
}

```

- 심지어 코틀린 1.4부터 이를 혼용할 수도 있다. 다만 원래 자리에 이름 붙은 인자를 지정해야 정상 처리된다. 그렇지 않다면 위치 기반 인자의 타입이 어긋나거나 이미 할당한 인자를 재할당해서 컴파일 에러가 난다.

## 오버로딩, 디폴드 값

- 자바와 비슷한 오버로딩 해소(Overloading resolution) 규칙을 따른다.
  1. 파라미터 개수와 타입을 기준으로 호출할 수 있는 모든 함수를 찾는다.
  2. 덜 구체적인 함수를 제외시킨다. (1에서 선택한 후보 목록에서 어떤 함수의 파라미터 타입이 다른 함수의 상위 타입인 경우 다른 함수보다 덜 구체적인 함수다. 덜 구체적인 함수가 없어질 때까지 반복한다.)
  3. 후보가 하나로 압축되면 호출 대상이다. 두 개 이상이면 컴파일 에러

```kotlin
fun mul(a: Int, b: Int) = a*b
fun mul(o: Any, n: Int) = Array(n){ o };

// 일반적으로
mul(1, 1);

//덜 구체적인 함수를 호출하려면 `as`로 타입 캐스팅
mul("0" as Any, 3)
```

- JS와 유사하게 함수 기본 값을 줄 수 있다.
```kotlin
fun readInt(radix : Int = 10) = readln().toInt(radix);

val decimal = readInt()
val hex = readInt(16)
```

- 파라미터 순서상 앞은 디폴트 뒤는 값을 대입하려면 `이름 붙은 인자`로 대입하면 된다. 물론 이렇게 안하는게 좋은 스타일이긴 하다. 

```kotlin
fun test(a: Int = 10, b: String = "HI") = println(a.toString() + b)

test(b = "HELLO!")
```

## vararg
- 코틀린에서도 자바 가변인자를 사용할 수 있다.
- `vararg` 키워드가 그 예다.
```kotlin
fun test ( vararg items: Int) {
    items.sort()
    println(items.contentToString())
}
```

- 추가로 배열을 가변 인자 대신 넘길 수도 있다. `*`를 사용해서 (스프레드 연산자라고 부른다. 스프레드는 배열을 복사한다. 원본을 유지한다는 의미다. 대신 얕은 복사다. 참조가 복사된다.)
```kotlin
fun printSorted(vararg items: Int) {
    println(items.contentToString())
}
fun main() {
  val a = intArrayOf(1,2,3,4)
  
  printSorted(*a)
  printSorted(1, 2, 3)
  printSorted(-2, -1, 0, *a) //하나의 배열로 재할당
}
```

## 함수의 영역과 가시성
코틀린 함수는 정의된 위치로 세 가지로 구분할 수 있다.

- 파일에 직접 선언된 최상위 함수 ( 공개 함수 = 프로젝트 어디서든 사용할 수 있다. )
- 어떤 타입 내부에 선언된 멤버 함수
- 다른 함수 안에 선언된 지역 함수 (클로저?)




## Package, Import

> vs. Java
> 대부분 비슷하지만 자바와 달리 코틀린은 `import static`이 없다. 코틀린의 모든 선언은 일반적인 import directive 구문을 사용하면 된다.

## Control flow statement

###  Condition
- 자바와 대다수가 유사하다.
- 코틀린은 if를 식으로 사용할 수 있다.

```kotlin
fun max (a: Int, b: Int) = if( a > b ) a else b //bracket 생략
fun main() {
  val s = readln()
  val i = s.indexOf("/")
  
  val result = if ( i >= 0 ) {
    val a = s.substring(0, i).toInt()
    val b = s.substring(i + 1).toInt();

    (a/b).toString() //return 없이 그냥 뱉을 수 있다.
  }
  else "" //bracket 생략
}
```

> vs. Java
> 코틀린은 3항 연산자가 없다. 대신 if를 식으로 쓸 수 있다.

> Kotlin!
> Any, Noting, Unit
> 
> - Any는 모든 타입의 조상 타입, 자바의 Object와 유사하다.
> - Nothing은 모든 타입의 서브 타입, 함수 내에서 return 자체를 하지 않는다.
> - Unit은 싱글톤 인스턴스로 자바의 void를 나타낸다.


#### 범위, 진행, 연산
코틀린은 순서가 정해진 값 사이 수열을 표현하는 몇 가지 타입을 제공한다.

```kotlin
val chars = 'a'..'z'
val twoDigits = 10..99
val zeroToOne = 0.0 .. 1.0

for( num in 10 .. 100) {
    println(num)
}

print(num in 10 .. 100)// 10 ~ 100
print(num !in 10 .. 100) //100 ~ 10

/**
 * <=, >= 를 사용할 수 있다면 ..로 범위를 만들 수 있다.
 */
print("def" in "abc" .. "xyz") //true
print("zzz" in "abc" .. "xyz") //false

```

- `..` 연산은 시작, 끝 include다.
- 시작 include, 끝 exclude 인 연산이 따로 있다. `until`이다. (혹은 `..<`)

```kotlin
print(a in 10..<100) //for
print(5 in 5..5) // 5 <= 5 <= 5
```
- 끝이 시작보다 작으면 빈 범위가 된다.

```kotlin
println(5  in 10 downTo 1) //아래로 내려가는 연산을 만들 수도 있다.
println(5 !in 1 .. 10)
```

- 스텝도 넣을 수 있다.
```kotlin
print(a in 1 .. 10 step 3)
```

- 이 연산은 substring, 배열에서도 유효하다. 
- 범위와 진행타입은 코틀린 표준 라이브러리 `IntRange`, `FloatRange`, `CharProgression`, `IntProgression` 등으로 정의돼 있다. `kotlin.ranges`를 살펴보자.


#### 연산자 우선순위

| type  |   operator   |                                                               example                                                               |
|:-----:|:------------:|:-----------------------------------------------------------------------------------------------------------------------------------:|
|  덧셈   |     +, -     |                                                   a + b .. c - d // a+b .. (c..d)                                                   |
|  범위   |      ..      |                                    a .. b step c // (a ..b ) step c<br/>a in b..c // a in (b..c)                                    |
|  중위   | in, or, and  | a < b or b < c // ( a < (b or b)) < c<br/> a == b and b == c // (a == b) and (b == c) <br/>a in b or a in c // (a in (b or a)) in c |
| 원소 검사 |   in, !in    |                                     a < b in c // a < (b in c)<br/>a !in b > c // (a !in b) > c                                     |
|  비교   | <, >, <=, >= |                           a < b == b < c // (a < b) == (b < c)<br/>a < b && b < c // (a < b ) && (b < c)                            |

#### When(caseSwitch)

```kotlin
fun hexDigit( n: Int ): Char {
    if( n in 0..9 ) return '0' + n
    else if( n in 10 .. 15 ) return 'A' + (n - 10)
    else return '?'
}

fun hexDigitWhen( n: Int ): Char {
  when {
      n in 0 .. 9 -> return '0' + n 
      n in 10 .. 15 -> return 'A' + (n - 10)
      else -> return '?'
  }
}
```

> vs. Java
> 분명 switch-case와 유사하다 대그러나 when의 임의의 조건을 검사할 수 있지만 switch는 주어진 식의 여러 가지 값 중 하나만 선택할 수 있다.
> 추가로 자바는 fall-through가 된다. 코틀린의 when은 절대 fall-through 하지 않는다.


```kotlin
fun numberDescription(n: Int, max: Int = 100): String = when( n ) {
    0 -> "zero"
    1, 2, 3 -> "Small"
    in 4..9 -> "Medium"
    in 10..max -> "Large"
    !in Int.MIN_VALUE ..< 0 -> "Negative"
    else -> "Huge!"
}
```

### Loop

#### while, do-while
- Java와 동일하다.

#### for, iterable
- Java와 유사하다.
- loop 변수에 val, var을 붙이지 않는다.
- 루프 변수는 자동으로 불변 값이 된다. 즉, 루프 몸통에서 루프 변수를 변경할 수 없다.
- 루프 변수 타입을 줄 수는 있지만 거의 쓰지 않는다.

```kotlin
fun main() {
  val a = IntArray(10) { it * it }
  var sum = 0
  
  for ( x: Int in a ) {
      sum += x
  }
}
```
> vs. Java
> - forEach와 유사한 모습이다. 배열, 리스트, 집합은 Iterable이며, 사용자 정의 타입도 Iterable일 수 있다.
> - 코틀린에서는 선언, 초기화, 검사, 갱신 for (int a = 0; i < 10; i ++) 같은 구조가 없다.
> - 심지어 문자에 대한 루프도 가능하다.
> - 코틀린은 iterator라는 함수만 있다면 for 루프가 가능하다.

```kotlin
fun parseIntNumber( s: String, fallback: Int = -1 ): Int {
  var num = 0
  if( s.length !in 1 .. 31 ) return fallback
  
  for ( c in s ) {
      if( c !in '0' .. '1') return fallback
      num = num * 2 + (c - '0')
  }
  
  return num
}
```

#### break, continue

- Java와 동일하다.

```kotlin
fun countLetters( text: String ): IntArray {
  val counts = IntArray('z' - 'a' + 1);
  
  for (char in text) {
      val charLower = char.toLowerCase();
      if( charLower !in 'a' .. 'z') continue
      counts[charLower - 'a'] ++ 
  }
  
  return counts
}
```

#### break,continue label
- Java에서는 for 앞에 label을 붙여서 break의 범위를 지정할 수 있다.
- 코틀린도 label 문법이 있지만 약간 다르다.

```kotlin
fun indexOf(subarray: IntArray, array: IntArray): Int {
  outerLoop@ for ( i in array.indices ) {
      for ( j in subarray.indices ) {
          if( subarray[j] != array[ i + j ] ) continue@outerLoop
      }
  }
  
  return i;
}
```


#### 꼬리 재귀 함수

> 꼬리재귀란?
> 일반 재귀는 조건에 따라 return하고 아니면 함수 자신을 재호출하여 계산해나간다. 
> 
> ```kotlin
> fun fibo ( num: Int ): Int {
>   if( num == 0 ) return 1;
>   else if( num == 1 ) return 2;
>   else return fibo(n - 1) + fibo(n - 2)
> }
> ```
> 
> 꼬리 재귀는 계산을 미리 해서 넘기며, 재귀 종료시 마지막에만 계산해서 리턴하면 될 수 있도록 구성되어 있다.
> ```kotlin
> fun fibo( num: Int ): Int {
>   return fiboTail(num, 0, 1);
> }
> fun fiboTail( num: Int, before: Int, next: Int): Int {
>   if(n == 0) return before
>   else return fiboTail(num - 1, num, before + next)
> }
> ```

코틀린은 꼬리 재귀함수에 대한 최적화 컴파일을 지원한다. 예를 들어 이진 탐색(BinarySearch)를 코틀린으로 작성한다고 생각해보자.

```kotlin
tailrec fun binIndexOf( x: Int, array: IntArray, from: Int = 0, to: Int = array.size ): Int {
  if( from == to ) return -1
  val midIndex = ( from + to - 1 ) / 2
  val mid = array[midIndex]
  
  return when {
      mid < x -> binIndexOf(x, array, midIndex + 1, to)
      mid > x -> binIndexOf(x, array, from, midIndex)
      else -> midIndex
  }
}
```

코틀린에서 `trailrec`을 붙이면 컴파일러가 재귀 함수를 비재귀적인 코드로 자동으로 변환하여 재귀 함수의 간결함과 비재귀 루프의 성능적 이득을 취할 수 있다.
위 코드는 아래와 같이 작동한다.

```kotlin
fun binIndexOf( x: Int, array: IntArray, from: Int = 0, to: Int = array.size ): Int {
  var fromIndex = from
  var toIndex = to
  
  while( true ) {
    if( fromIndex == toIndex ) return -1
    val midIndex = (fromIndex + toIndex - 1) / 2
    val mid = array[midIndex]

    when {
      mid < x -> fromIndex = midIndex + 1
      mid > x -> toIndex = midIndex
      else -> return midIndex
    }
  }
}
```

이렇게 변환하려면 딱 재귀만 해야 한다. 애초에 그게 꼬리 재귀가 뜻하는 바이기도 하다. 만약 `tailrec`을 붙였는데 꼬리재귀가 아니면 경고를 표시하고 일반 재귀로 컴파일한다.


## 예외처리