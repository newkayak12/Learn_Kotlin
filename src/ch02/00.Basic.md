# 기본 문법

## 주석
|표현|    설명    |
|:---:|:--------:|
|//  |    주석    |
|/* */ |  여러 줄 주석 |
|/** */ |   KDoc   |


## 변수 정의

### 식별자
변수, 함수 등 프로그램에 정의된 대상에 붙은 이름

1. 식별자는 오직 문자, 숫자, 밑줄만 포함, 숫자로 식별자 시작 불가
2. 밑줄로만 이뤄질 수 있다. '_', '__', '___' 는 예약어
3. 하드 키워드는 식별자로 불가 - (val, fun 등 -> 소트 키워드 : import 등)

> vs. Java
> - $를 식별자로 쓸 수 없다.
> - \`\`로 감싸는 경우도 식별자로 사용할 수 있다.
> 
> val `fun` = 1
> val `name with spaces` = 2


### 가변 변수
`val`은 불변 변수다. 한 번 초기화하면 다시는 값을 대입할 수 없는 변수다. (java final) 이를 하면 함수가 부수효과(SideEffect)가 줄어든다. 함수형 스타일
코드를 장려할 수 있다. 또한 코드 추론이 쉬워진다. 

`var`은 mutable한 변수를 정의할 수 있다. 

> vs. Java
> 코틀린 대입은 대입문이라 return 이 없다.
> a = b = c 와 같은 케이스를 사용할 수 없다.


## 기본 타입

자바의 원시 타입과 비슷하지만 다르다. 1:1 대응은 아니다. 자바는 값 타임, 참조 타입 간의 차이가 확실하다. 코틀린은 상황에 따라 참조와 원시 타입을 가리키기 
때문에 구분이 모호하다. 자바는 박싱 타입이 따로 있지만 코틀린은 암묵적으로 수행한다.


> vs. Java
> - 코틀린의 모든 타입은 클래스 정의를 기반으로 만들어진다. 원시 타입과 비슷한 타입들도 메소드와 프로퍼티를 제공한다. 
> - 타입은 하위 타입이라는 개념으로 게층화할 수 있다. 

### 정수 타입
 
- Byte
- Short
- Int
- Long

### 부동소수점

- Float
- Double

```kotlin
val quarter = .25 //0이 생략됨
```


### 수 변환
각 수 타입마다 값을 다른 수 타입으로 변환하는 연산이 정의돼 있다. 

- toByte()
- toShort()
- toInt()
- toLong()
- toFloat()
- toDouble()

### 비교 동등성

1. 둘 다 같은 타입일 때 비교 가능
```kotlin
val a = 1;
val b = 2L

println(a == b) // Error: comparing Int And Long
println(a.toLong() == b) //OK!
```

## Bool 타입, 논리 연산

- ! : 논리 부정
- or(| 대체), and(& 대체), xor : 논리합, 논리곱, 논리배타합
- ||, && : 지연 계산 방식의 논리합, 논리곱

## 문자열
1. 코틀린은 \"\" 사이에 `${}`으로 interpolation을 할 수 있다.
2. raw 문자열을 사용하면 이스케이프 없이 쓸 수도 있다.

```kotlin
val message = """
    Hello, $name!
""".trimIndent()
```

### 문자열 연산

> vs. Java
> 자바의 ==, !=는 참조 동등성을 비교한다. 그래서 equals()를 사용해야만 한다.
> 코틀린에서는 == 가 equals()를 가리키는 편의 문법이다.
> 
> 문자열은 사전식으로 정렬되기에(lexicographically) `<`, `>`, `<=`, `>=`으로 비교할 수 있다.

## 배열
1. 배열 구조를 구현하는 가장 일반적인 코틀린 타입은 `Array<T>`이다.
2. 추가로 Array<Int>는 작동은 하지만 모든 수를 박싱한다. `ByteArray`, `ShortArray`, `IntArray`, `LongArray`, `FloatArray`, `DoubleArray`, `CharArray`, `BooleanArray`처럼 박싱하지 않는 배열이 구현되어 있다.
3. 배열 타입의 변수 자체는 실제 데이터에 대한 참조를 저장한다.
4. 코틀린 배열은 모든 다른 배열 타입과 서로 하위 타입 관계가 성립하지 않는다고 간주되며 `Array<String>`은 `Array<Any>`의 하위가 아니다.







## 함수 
- `fun`는 컴파일러에게 함수 정의가 뒤따라온다는 사실을 알려준다.
- 아무 식별자나 함수명으로 쓸 수 있다.
- 자바는 final을 붙여야 불변 값으로 바꿀 수 있는데 코틀린은 함수 파라미터는 무조건 불변

```java
public int test (final int a ) {return a;}
```
```kotlin
fun test( a: Int ) : Int {return a}
```

- 코틀린 파라미터 앞에 val, var을 표시할 수 없다.
- 코틀린의 값에 의한 호출을 사용한다. (호출하는 쪽의 인자를 복사한다.)
- 파라미터에는 항상 타입을 지정해야 한다. 컴파일러는 함수 정의에서 파라미터 타입은 추론하지 못한다.
- 반환 타입은 추론가능하지만 명시해야 한다. 그러나 함수 본문에서 모든 반환 지점을 보고 추론하기 어려울 수 있기에 명시한다.
- 경우에 따라 생략할 수 있다. 첫 번째는 unit 타입 반환(자바의 void), 두 번째는 식이 본문 식인 함수다. 함수가 어떤 단일 식으로만 구현될 수 있다면 `return`, `{}`를 생략하고 작성할 수 있다.

```kotlin
import kotlin.math.PI
import kotlin.math.pow

fun circleArea1(radius: Double) = PI * radius.pow(2.0)
fun circleArea2(radius: Double) = {PI * radius.pow(2.0)} // 블록이 본문인 함수를 정의할 때 {} 앞에 =를 넣으면 익명 함수를 기술하는 람다로 해석된다.
```

